/**
 * All content on this website (including text, images, source
 * code and any other original works), unless otherwise noted,
 * is licensed under a Creative Commons License.
 * 
 * http://creativecommons.org/licenses/by-nc-sa/2.5/
 * 
 * Copyright (C) Open-Xchange Inc., 2011
 * Mail: info@open-xchange.com 
 * 
 * @author Viktor Pracht <viktor.pracht@open-xchange.com>
 */

var fs = require("fs");
var path = require("path");
var child_process = require("child_process");
var globSync = require("./glob").globSync;
var _ = require("../underscore");

/**
 * Default destination directory.
 * @type String
 * @name exports.builddir
 */

/**
 * Resolves a filename relative to the build directory.
 * @param {String} name The filename to resolve
 * @type String
 * @return The filename in the build directory.
 */
exports.dest = function(name) { return path.join(exports.builddir, name); };

/**
 * Number of generated files.
 * @type Number
 */
var counter = 0;

exports.startTime = new Date;

/**
 * Types of files which are processed with the same settings.
 * Each type consists of an array of handlers for dependency-building and
 * an array of filters to process the file contents.
 * The special type "*" is applies to all files and is applied after
 * the type-specific handlers and filters.
 */
var types = { "*": { handlers: [], filters: [] } };

/**
 * Adds a handler to the specified type.
 * @param {String} type The type to which the handler is added.
 * @param {Function} handler The handler function which is called for every file
 * of the specified type, with the target filename as parameter.
 */
exports.addHandler = function(type, handler) {
    var t = types[type];
    if (!t) t = types[type] = { handlers: [], filters: [] };
    t.handlers.push(handler);
};

/**
 * Adds a filter to the specified type.
 * @param {String} type The type to which the filter is added.
 * @param {Function} filter The filter function which is called for every file
 * of the specified type, with the file data as a string parameter. It should
 * return the filtered data as a string.
 */
exports.addFilter = function(type, filter) {
    var t = types[type];
    if (!t) t = types[type] = { handlers: [], filters: [] };
    t.filters.push(filter);
};

/**
 * The name of the current top level task, if any-
 */
var topLevelTaskName = null;

/**
 * Defines a new top-level task.
 * Any subsequent file utility functions will add their target files to this
 * task as dependencies.
 * @param {String} name An optional name of the new task. If not specified,
 * no new task is created and automatic dependencies won't be created anymore.
 */
exports.topLevelTask = function(name) {
    topLevelTaskName = name;
    if (name) return task.apply(this, arguments);
};

exports.addHandler("*", function(filename) {
    if (topLevelTaskName) task(topLevelTaskName, [filename]);
});

/**
 * Callback for top-level tasks to report the number of generated files and the
 * build time.
 */
exports.summary = function() {
    var seconds = ((new Date).getTime() - exports.startTime.getTime()) / 1000;
    console.log("Generated " + counter + (counter == 1 ? " file" : " files") +
        " in " + seconds.toFixed(3) + "s");
};

/**
 * Copies one or more files.
 * Any missing directories are created automatically.
 * @param {Array} files An array of strings specifying filenames to copy.
 * @param {String} files.dir An optional common parent directory. All filenames
 * in files are relative to it. Defaults to the project root.
 * @param {Object} options An optional object containing various options.
 * @param {String} options.to An optional target directory. The target
 * filenames are generated by resolving each filename from files relative to
 * options.to instead of files.dir. Defaults to the build directory.
 * @param {Function} options.filter An optional filter function which takes
 * the contents of a file as parameter and returns the filtered contents.
 * @param {Function} options.mapper An optional file name mapper.
 * It's a function which takes the original target file name (as computed by
 * files.dir and options.to) as parameter and returns the mapped file name.
 */
exports.copy = function(files, options) {
    var srcDir = files.dir || "";
    var destDir = options && options.to || exports.builddir;
    var mapper = options && options.mapper || function(f) { return f; };
    for (var i = 0; i < files.length; i++) {
        exports.copyFile(path.join(srcDir, files[i]),
                         mapper(path.join(destDir, files[i])), options);
    }
};

/**
 * Returns a combined handler and a combined filter function for a combination
 * of filename and options.
 * @param {String} filename The name of the target file.
 * @param {Object} options An optional object with options for copy or concat.
 * @param {Function} options.filter An optional filter function which takes
 * the contents of a file as parameter and returns the filtered contents.
 * @param {String} options.type An optional file type. Defaults to the file
 * extension of the destination.
 * @type Object
 * @returns An object with two methods: handler and filter.
 * handler should be called to generate dependencies. If filter is not null,
 * It should be called with the contents of the file as a string parameter.
 * It will then return the filtered file contents as a string.
 */
function getType(filename, options) {
    if (!options) options = {};
    var type = options.type || path.extname(filename);
    type = types[type] || { handlers: [], filters: [] };
    var handlers = [].concat(type.handlers, types["*"].handlers);
    var filters = [].concat(options.filter || [], type.filters,
                            types["*"].filters);
    return {
        handler: function(filename) {
            for (var i = 0; i < handlers.length; i++) handlers[i](filename);
        },
        filter: filters.length ? function(data, getSrc) {
            for (var i = 0; i < filters.length; i++) {
                data = filters[i].call(this, data, getSrc);
            }
            return data;
        } : null
    };
}

/**
 * Copies a single file.
 * Any missing directories are created automatically.
 * @param {String} src The filename of the source file.
 * @param {String} dest The filename of the target file.
 * @param {Object} options An optional object containing various options.
 * @param {Function} options.filter An optional filter function which takes
 * the contents of a file as parameter and returns the filtered contents.
 * @param {String} options.type An optional file type. Defaults to the file
 * extension of the destination.
 */
exports.copyFile = function(src, dest, options) {
    var dir = path.dirname(dest);
    directory(dir);
    var type = getType(dest, options);
    var callback = type.filter ?
        function() {
            fs.writeFileSync(dest,
                type.filter.call(this, fs.readFileSync(src, "utf8"),
                    function(line) { return { name: src, line: line }; }));
            counter++;
        } : function() {
            var data = fs.readFileSync(src);
            fs.writeFileSync(dest, data, 0, data.length, null);
            counter++;
        };
    file(dest, [src, dir, "Jakefile.js"], callback);
    type.handler(dest);
};

/**
 * Concatenates one or more files and strings to a single file.
 * Any missing directories are created automatically.
 * @param {String} name The name of the destination file relative to the build
 * directory.
 * @param {Array} files An array of things to concatenate.
 * Plain strings are interpreted as filenames relative to files.dir,
 * objects having a method getData should return the contents as a string.
 * @param {String} files.dir An optional common parent directory. All filenames
 * in files are relative to it. Defaults to the project root.
 * @param {Object} options An optional object containing various options.
 * @param {String} options.to An optional target directory. The target
 * filenames are generated by resolving each filename from files relative to
 * options.to instead of files.dir. Defaults to the build directory.
 * @param {Function} options.filter An optional filter function which takes
 * the concatenated contents as parameter and returns the filtered contents.
 * @param {String} options.type An optional file type. Defaults to the file
 * extension of the destination.
 */
exports.concat = function(name, files, options) {
    var srcDir = files.dir || "";
    var dest = path.join(options && options.to || exports.builddir, name);
    var destDir = path.dirname(dest);
    var deps = [];
    var type = getType(dest, options);
    for (var i = 0; i < files.length; i++) {
        if (typeof files[i] == "string") deps.push(path.join(srcDir, files[i]));
    }
    deps.push(destDir);
    deps.push("Jakefile.js");
    directory(destDir);
    file(dest, deps, function() {
        var fd = fs.openSync(dest, "w");
        if (type.filter) {
            var data = [], fileDefs = [], start = 0;
            for (var i = 0; i < files.length; i++) {
                if (typeof files[i] == "string") {
                    var src = path.join(srcDir, files[i]);
                    var contents = fs.readFileSync(src, "utf8");
                    var last = contents.charAt(contents.length - 1);
                    if (last != "\r" && last != "\n") contents += "\n";
                    data.push(contents);
                    fileDefs.push({ name: src, start: start });
                    start += contents.split(/\r?\n|\r/g).length - 1;
                } else {
                    data.push(typeof files[i] == "string" ?
                            fs.readFileSync(path.join(srcDir, files[i]), "utf8") :
                            files[i].getData());
                }
            }
            fs.writeSync(fd, type.filter.call(this, data.join(""), getSrc),
                         null);
            function getSrc(line) {
                var def = fileDefs[_.sortedIndex(fileDefs, line, getStart) - 1];
                function getStart(x) {
                    return typeof x == "number" ? x : x.start;
                }
                return { name: def.name, line: line - def.start };
            }
        } else {
            for (var i = 0; i < files.length; i++) {
                var data = typeof files[i] == "string" ?
                    fs.readFileSync(path.join(srcDir, files[i])) :
                    new Buffer(files[i].getData());
                fs.writeSync(fd, data, 0, data.length, null);
            }
        }
        fs.closeSync(fd);
        counter++;
    });
    type.handler(dest);
};

/**
 * Returns a list of filenames specified by a root directory and one or more
 * glob patterns.
 * @param {String} dir Optional root directory. Defaults to the project root.
 * @param {String or Array of String} globs One or more glob patterns.
 * @type Array of String
 * @returns An array of file names relative to dir, which match the specified
 * patterns.
 * The property dir is set to the parameter dir for use with copy and concat.
 */
exports.list = function(dir, globs) {
    if (globs === undefined) {
        globs = dir;
        dir = "";
    }
    if (typeof globs == "string") globs = [globs];
    var arrays = globs.map(function(s) { return globSync(dir, s); });
    var retval = Array.prototype.concat.apply([], arrays);
    retval.dir = dir;
    return retval;
};

/**
 * Asynchronously executes an external command.
 * stdin, stdout and stderr are passed through to the parent process.
 * @param {String} command The command to execute.
 * @param {Array} args An array of parameters.
 * @param {Function} callback A callback which is called when the command
 * returns.
 */
exports.exec = function(command, args, callback) {
    var child = child_process.spawn("/usr/bin/env", [command].concat(args),
        { customFds: [0, 1, 2] });
    child.on("exit", callback);
};

/**
 * Merges two sorted arrays based on an optional comparison function
 * (like Array.prototype.sort).
 * @param {Array} a The first array.
 * @param {Array} b The second array.
 * @type Array
 * @return A sorted array with elements from a and b, except for duplicates
 * from b. All entries from a are included. 
 */
exports.merge = function(a, b, cmp) {
    if (!cmp) cmp = function(x, y) { return x < y ? -1 : x > y ? 1 : 0; };
    var c = Array(a.length + b.length);
    var ai = 0, bi = 0, ci = 0;
    while (ai < a.length && bi < b.length) {
        var diff = cmp(a[ai], b[bi]);
        c[ci++] = diff > 0 ? b[bi++] : a[ai++];
        if (!diff) bi++;
    }
    while (ai < a.length) c[ci++] = a[ai++];
    while (bi < b.length) c[ci++] = b[bi++];
    c.length = ci;
    return c;
};

var includes = {};
var includesFile;

/**
 * Specifies a file which stores include information between builds, and loads
 * it if it already exists.
 * @param {String} filename The file which stores include information between
 * builds.
 */
exports.loadIncludes = function(filename) {
    includesFile = filename;
    if (path.exists(filename)) {
        includes = JSON.parse(fs.readFileSync(filename, "utf8"));
        for (var i in includes) file(i, includes[i]);
    }
};

/**
 * Adds an include found in a source file.
 * @param {String} file The file which contains the include.
 * @param {String} include Name of the included file.
 */
exports.addInclude = function(file, include) {
    (includes[file] || (includes[file] = [])).push(include);
};

/**
 * Specifies which includes were found in a source file.
 * @param {String} file The file which contains the includes.
 * @param {Array} includedFiles An array with names of included files.
 */
exports.setIncludes = function(file, includedFiles) {
    includes[file] = includedFiles;
};

/**
 * Saves the list of inlcudes to the file previously specified by loadIncludes.
 */
exports.saveIncludes = function() {
    for (var i in includes) if (!includes[i].length) delete includes[i];
    fs.writeFileSync(includesFile, JSON.stringify(includes));
};