<h1>Internationalization</h1>

<h2>Introduction</h2>

<p>Providing software for users in the whole world means providing it in
multiple languages. This consists of two steps:</p>
<ul>
    <li><em>Internationalization (i18n)</em> - Making the software
    international, i. e. preparing it to be adapted to different languages and
    locations.</li>
    <li><em>Localization (L10n)</em> - Adapting the software to a particular
    language and/or location.</li>
</ul>
<p>The Open-Xchange platform offers several facilities to simplify both parts.
The L10n part is mostly a concern for translators. Open-Xchange facilities
consist mainly of using a well-established format for translations:
<a href="http://www.gnu.org/s/gettext/">GNU Gettext</a> Portable Object (PO)
files. This allows translators to use existing dedicated translation tools or
a simple UTF-8-capable text editor.</p>
<p>The i18n part is what software developers will be mostly dealing with and is
what the rest of this document describes.</p>

<h2>Translation</h2>

<p>The main part of i18n is the translation of various text strings which are
presented to the user. For this purpose, the Open-Xchange platform provides
the RequireJS plugin <code>"gettext"</code>. Individual translation files are
specified as a module dependency of the form
<code>"gettext!<var>module_name</var>"</code>. The resulting module API is
a function which can be called to translate a string using the specified
translation files:</p>
<script type="text/example">
define('com.example/example', ['gettext!com.example/example'],
    function (gt) {
        'use strict';
        alert(gt('Hello, world!'));
    });
</script>
<p>After building the module, the file ox.pot in the project's root directory
will contain an entry for every call to one of <code>gettext</code> functions:
</p>
<pre class="nocode prettyprint">
<code class="com">#: apps/com.example/example.js:4</code>
<code class="kwd">msgid</code> <code class="str">"Hello, world!"</code>
<code class="kwd">msgstr</code> <code class="str">""</code>
</pre>
<p>After translation, the PO files in the directory <code>i18n</code> shoud
contain the translated entry:</p>
<pre class="nocode prettyprint">
<code class="com">#: apps/com.example/example.js:4</code>
<code class="kwd">msgid</code> <code class="str">"Hello, world!"</code>
<code class="kwd">msgstr</code> <code class="str">"Hallo, Welt!"</code>
</pre>
<p>During the next build, the entries are copied from the central PO files
into individual translation files. In our example, this would be
<code>apps/com.example/example.de_DE.js</code>. Because of the added language
ID, translation files can usually have the same name as the corresponding main
module. Multiple related modules should use the same translation file to avoid
the overhead of too many small translation files.</p>

<h2>Advanced <code>gettext</code> Functions</h2>

<p>Most modules will require more complex translations than can be provided by
a simple string lookup. To handle some of these cases, the <code>gettext</code>
module provides traditional methods in addition to being a callable function.
Other cases are handled by the build system.</p>

<h3>Composite Phrases</h3>

<p>In most cases, the translated texts will not be static, but contain dynamic
values as parts of a sentence. The straight-forward approach of translating
parts of the sentence individually and then using string concatenation to
compose the final text is a <em><st>BAD</st></em> idea. Different languages have
different sentence structures, and if there are multiple dynamic values, their
order might need to be reversed in some languages, and not reversed in others.
</p>
<p>The solution is to translate entire sentences and then to use the function
<code>gettext.format</code> to insert dynamic values:</p>
<script type="text/example">
alert(gt.format(
    //#. %1$s is the given name
    //#. %2$s is the family name
    //#, c-format
    gt('Welcome, %1$s %2$s!'), firstName, lastName);
</script>
<p>Results in:</p>
<pre class="nocode prettyprint">
<code class="com">#. %1$s is the given name</code>
<code class="com">#. %2$s is the family name</code>
<code class="com">#, c-format</code>
<code class="kwd">msgid</code> <code class="str">"Welcome, %1$s, %2$s"</code>
<code class="kwd">msgstr</code> <code class="str">""</code>
</pre>
<p>As shown in the example, it is possible to add comments for translators by
Starting a comment with "<code>#.</code>". Such comments must be placed
immediately before the name of the variable which refers to
the <code>gettext</code> module (in this case <code>gt</code>). They can be
separated by arbitrary whitespace and newlines, but not other tokens. All
<code>format</code> calls should have comments explaining every format
specifier.</p>
<p>Comments starting with "<code>#,</code>" are meant for Gettext tools, which
in the case of "<code>#, c-format</code>", can ensure that the translator did
not leave out or mistype any of the format specifiers.</p>

<h3>Contexts</h3>

<p>Sometimes, the same English phrase has multiple meanings and must be
translated differently depending on context. To be able to tell
the individual translations apart, the method <code>gettext.pgettext</code>
('p' stands for 'particular') should be used instead of calling
<code>gettext</code> directly. It takes the context as the first parameter
and the text to translate as the second parameter:</p>
<script type="text/example">
alert(gt.pgettext('description', 'Title'));
alert(gt.pgettext('salutation', 'Title'));
</script>
<p>Results in:</p>
<pre class="nocode prettyprint">
<code class="kwd">msctxt</code> <code class="str">"description"</code>
<code class="kwd">msgid</code> <code class="str">"Title"</code>
<code class="kwd">msgstr</code> <code class="str">"Beschreibung"</code>

<code class="kwd">msctxt</code> <code class="str">"salutation"</code>
<code class="kwd">msgid</code> <code class="str">"Title"</code>
<code class="kwd">msgstr</code> <code class="str">"Anrede"</code>
</pre>

<h3>Plural forms</h3>

<p>In the case of numbers, the rules to select the proper plural form can be
very complex. After not having any plural forms at all, English is the second
simplest language in this respect, having only two plural forms: singular and
plural. Other languages can have up to four forms, and theoretically even more.
The functions <code>gettext.ngettext</code> and <code>gettext.npgettext</code>
(for a combination of plural forms with contexts) can select the proper plural
form by using a piece of executable code embedded in the header of a PO file:
</p>
<script type="text/example">
alert(gt.format(
    //#. %1$d is the number of mails
    //#, c-format
    gt.ngettext('You have %1$d mail', 'You have %1$d mails', n),
    n));
</script>
<p>The function <code>ngettext</code> accepts three parameters: the English
singular and plural forms and the number which determines the chosen plural
form. The function <code>npgettext</code> adds a context parameter before
the others, similar to <code>pgettext</code>.</p>
<p>The above example results in the following entry:</p>
<pre class="nocode prettyprint">
<code class="com">#. %1$d is the number of mails</code>
<code class="com">#, c-format</code>
<code class="kwd">msgid</code> <code class="str">"You have %1$d mail"</code>
<code class="kwd">msgid_plural</code> <code class="str">"You have %1$d mails"</code>
<code class="kwd">msgstr[0]</code> <code class="str">""</code>
<code class="kwd">msgstr[1]</code> <code class="str">""</code>
</pre>
<p>The number of <code>msgstr[<var>N</var>]</code> lines is determined by
the number of plural forms in each language. This number is specified in the
header of each PO file, together with the code to compute the index of
the correct plural form from the supplied number.</p>
